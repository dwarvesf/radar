"use strict";var _interopRequireWildcard=require("@babel/runtime-corejs2/helpers/interopRequireWildcard");var _interopRequireDefault=require("@babel/runtime-corejs2/helpers/interopRequireDefault");exports.__esModule=true;exports.render=render;exports.renderError=renderError;exports.default=exports.emitter=exports.ErrorComponent=exports.router=exports.dataManager=exports.version=void 0;var _asyncToGenerator2=_interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));var _extends2=_interopRequireDefault(require("@babel/runtime-corejs2/helpers/extends"));var _promise=_interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));var _react=_interopRequireWildcard(require("react"));var _reactDom=_interopRequireDefault(require("react-dom"));var _headManager=_interopRequireDefault(require("./head-manager"));var _router=require("next/router");var _mitt=_interopRequireDefault(require("../next-server/lib/mitt"));var _utils=require("../next-server/lib/utils");var _pageLoader=_interopRequireDefault(require("./page-loader"));var envConfig=_interopRequireWildcard(require("../next-server/lib/runtime-config"));var _headManagerContext=require("../next-server/lib/head-manager-context");var _dataManagerContext=require("../next-server/lib/data-manager-context");var _routerContext=require("../next-server/lib/router-context");var _dataManager=require("../next-server/lib/data-manager");var _querystring=require("querystring");var _isDynamic=require("../next-server/lib/router/utils/is-dynamic");/* global location */ // Polyfill Promise globally
// This is needed because Webpack's dynamic loading(common chunks) code
// depends on Promise.
// So, we need to polyfill it.
// See: https://webpack.js.org/guides/code-splitting/#dynamic-imports
if(!window.Promise){window.Promise=_promise.default;}const data=JSON.parse(document.getElementById('__NEXT_DATA__').textContent);window.__NEXT_DATA__=data;const version="9.0.6";exports.version=version;const{props,err,page,query,buildId,assetPrefix,runtimeConfig,dynamicIds}=data;const d=JSON.parse(window.__NEXT_DATA__.dataManager);const dataManager=new _dataManager.DataManager(d);exports.dataManager=dataManager;const prefix=assetPrefix||'';// With dynamic assetPrefix it's no longer possible to set assetPrefix at the build time
// So, this is how we do it in the client side at runtime
__webpack_public_path__=prefix+"/_next/";//eslint-disable-line
// Initialize next/config with the environment configuration
envConfig.setConfig({serverRuntimeConfig:{},publicRuntimeConfig:runtimeConfig||{}});const asPath=(0,_utils.getURL)();const pageLoader=new _pageLoader.default(buildId,prefix);const register=(_ref)=>{let[r,f]=_ref;return pageLoader.registerPage(r,f);};if(window.__NEXT_P){window.__NEXT_P.map(register);}window.__NEXT_P=[];window.__NEXT_P.push=register;const headManager=new _headManager.default();const appElement=document.getElementById('__next');let lastAppProps;let webpackHMR;let router;exports.router=router;let ErrorComponent;exports.ErrorComponent=ErrorComponent;let Component;let App;class Container extends _react.default.Component{componentDidCatch(err,info){this.props.fn(err,info);}componentDidMount(){this.scrollToHash();// If page was exported and has a querystring
// If it's a dynamic route or has a querystring
if(data.nextExport&&((0,_isDynamic.isDynamicRoute)(router.pathname)||location.search||data.skeleton)){// update query on mount for exported pages
router.replace(router.pathname+'?'+(0,_querystring.stringify)((0,_extends2.default)({},router.query,(0,_querystring.parse)(location.search.substr(1)))),asPath,{// WARNING: `_h` is an internal option for handing Next.js
// client-side hydration. Your app should _never_ use this property.
// It may change at any time without notice.
_h:1});}}componentDidUpdate(){this.scrollToHash();}scrollToHash(){let{hash}=location;hash=hash&&hash.substring(1);if(!hash)return;const el=document.getElementById(hash);if(!el)return;// If we call scrollIntoView() in here without a setTimeout
// it won't scroll properly.
setTimeout(()=>el.scrollIntoView(),0);}render(){return this.props.children;}}const emitter=(0,_mitt.default)();exports.emitter=emitter;var _default=/*#__PURE__*/function(){var _ref2=(0,_asyncToGenerator2.default)(function*(_temp){let{webpackHMR:passedWebpackHMR}=_temp===void 0?{}:_temp;// This makes sure this specific lines are removed in production
if(process.env.NODE_ENV==='development'){webpackHMR=passedWebpackHMR;}App=yield pageLoader.loadPage('/_app');let initialErr=err;try{Component=yield pageLoader.loadPage(page);if(process.env.NODE_ENV!=='production'){const{isValidElementType}=require('react-is');if(!isValidElementType(Component)){throw new Error("The default export is not a React Component in page: \""+page+"\"");}}}catch(error){// This catches errors like throwing in the top level of a module
initialErr=error;}if(window.__NEXT_PRELOADREADY){yield window.__NEXT_PRELOADREADY(dynamicIds);}exports.router=router=(0,_router.createRouter)(page,query,asPath,{initialProps:props,pageLoader,App,Component,wrapApp,err:initialErr,subscription:(_ref3,App)=>{let{Component,props,err}=_ref3;render({App,Component,props,err,emitter});}});const renderCtx={App,Component,props,err:initialErr,emitter};render(renderCtx);return emitter;});return function(_x){return _ref2.apply(this,arguments);};}();exports.default=_default;function render(_x2){return _render.apply(this,arguments);}// This method handles all runtime and debug errors.
// 404 and 500 errors are special kind of errors
// and they are still handle via the main render method.
function _render(){_render=(0,_asyncToGenerator2.default)(function*(props){if(props.err){yield renderError(props);return;}try{yield doRender(props);}catch(err){yield renderError((0,_extends2.default)({},props,{err}));}});return _render.apply(this,arguments);}function renderError(_x3){return _renderError.apply(this,arguments);}// If hydrate does not exist, eg in preact.
function _renderError(){_renderError=(0,_asyncToGenerator2.default)(function*(props){const{App,err}=props;// In development runtime errors are caught by react-error-overlay
// In production we catch runtime errors using componentDidCatch which will trigger renderError
if(process.env.NODE_ENV!=='production'){return webpackHMR.reportRuntimeError(webpackHMR.prepareError(err));}// Make sure we log the error to the console, otherwise users can't track down issues.
console.error(err);exports.ErrorComponent=ErrorComponent=yield pageLoader.loadPage('/_error');// In production we do a normal render with the `ErrorComponent` as component.
// If we've gotten here upon initial render, we can use the props from the server.
// Otherwise, we need to call `getInitialProps` on `App` before mounting.
const AppTree=wrapApp(App);const appCtx={Component:ErrorComponent,AppTree,router,ctx:{err,pathname:page,query,asPath,AppTree}};const initProps=props.props?props.props:yield(0,_utils.loadGetInitialProps)(App,appCtx);yield doRender((0,_extends2.default)({},props,{err,Component:ErrorComponent,props:initProps}));});return _renderError.apply(this,arguments);}let isInitialRender=typeof _reactDom.default.hydrate==='function';function renderReactElement(reactEl,domEl){// mark start of hydrate/render
if(_utils.SUPPORTS_PERFORMANCE_USER_TIMING){performance.mark('beforeRender');}// The check for `.hydrate` is there to support React alternatives like preact
if(isInitialRender){_reactDom.default.hydrate(reactEl,domEl,markHydrateComplete);isInitialRender=false;}else{_reactDom.default.render(reactEl,domEl,markRenderComplete);}}function markHydrateComplete(){if(!_utils.SUPPORTS_PERFORMANCE_USER_TIMING)return;performance.mark('afterHydrate');// mark end of hydration
performance.measure('Next.js-before-hydration','navigationStart','beforeRender');performance.measure('Next.js-hydration','beforeRender','afterHydrate');clearMarks();}function markRenderComplete(){if(!_utils.SUPPORTS_PERFORMANCE_USER_TIMING)return;performance.mark('afterRender');// mark end of render
const navStartEntries=performance.getEntriesByName('routeChange','mark');if(!navStartEntries.length){return;}performance.measure('Next.js-route-change-to-render',navStartEntries[0].name,'beforeRender');performance.measure('Next.js-render','beforeRender','afterRender');clearMarks();}function clearMarks(){;['beforeRender','afterHydrate','afterRender','routeChange'].forEach(mark=>performance.clearMarks(mark));/*
   * TODO: uncomment the following line when we have a way to
   * expose this to user code.
   */ // performance.clearMeasures()
}function AppContainer(_ref4){let{children}=_ref4;return _react.default.createElement(Container,{fn:error=>renderError({App,err:error}).catch(err=>console.error('Error rendering page: ',err))},_react.default.createElement(_react.Suspense,{fallback:_react.default.createElement("div",null,"Loading...")},_react.default.createElement(_routerContext.RouterContext.Provider,{value:(0,_router.makePublicRouterInstance)(router)},_react.default.createElement(_dataManagerContext.DataManagerContext.Provider,{value:dataManager},_react.default.createElement(_headManagerContext.HeadManagerContext.Provider,{value:headManager.updateHead},children)))));}const wrapApp=App=>props=>{const appProps=(0,_extends2.default)({},props,{Component,err,router});return _react.default.createElement(AppContainer,null,_react.default.createElement(App,appProps));};function doRender(_x4){return _doRender.apply(this,arguments);}function _doRender(){_doRender=(0,_asyncToGenerator2.default)(function*(_ref5){let{App,Component,props,err}=_ref5;// Usual getInitialProps fetching is handled in next/router
// this is for when ErrorComponent gets replaced by Component by HMR
if(!props&&Component&&Component!==ErrorComponent&&lastAppProps.Component===ErrorComponent){const{pathname,query,asPath}=router;const AppTree=wrapApp(App);const appCtx={router,AppTree,Component:ErrorComponent,ctx:{err,pathname,query,asPath,AppTree}};props=yield(0,_utils.loadGetInitialProps)(App,appCtx);}Component=Component||lastAppProps.Component;props=props||lastAppProps.props;const appProps=(0,_extends2.default)({},props,{Component,err,router// lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.
});lastAppProps=appProps;emitter.emit('before-reactdom-render',{Component,ErrorComponent,appProps});// We catch runtime errors using componentDidCatch which will trigger renderError
renderReactElement(_react.default.createElement(AppContainer,null,_react.default.createElement(App,appProps)),appElement);emitter.emit('after-reactdom-render',{Component,ErrorComponent,appProps});});return _doRender.apply(this,arguments);}